---
title: "`r params$new_title`"
author: "Nicolas"
date: "`r Sys.Date()`"
output:
  html_document: 
    df_print: paged
    number_sections: yes
    toc: yes
    theme: cosmo
editor_options: 
  chunk_output_type: console
params:
  new_title: 'Results for instance '
  currentInstance: 'AS_5_3_2box_1_10_1'
---
 
```{r setup, include=FALSE}
#' Function for loading missing packages that install them if not already installed.
#'
#' @param packages String vector with package names
#'
#' @return NULL (invisible)
#' @export
#'
#' @examples loadPackages(c("MASS", "ggplot2", "tikzDevice"))
loadPackages <- function(packages) {
  newP <- packages[!(packages %in% installed.packages()[,"Package"])]
  if(length(newP)) install.packages(newP, repos = "http://cran.rstudio.com/")
  lapply(packages, library, character.only = TRUE)
  invisible(NULL)
}
loadPackages(c("tidyverse", "knitr", "rgl", "gMOIP", "rmarkdown"))
options(rgl.useNULL=TRUE)
options(rgl.printRglwidget=FALSE)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "",
  warning=FALSE, message=FALSE, include = TRUE, 
  out.width = "99%", fig.width = 8, fig.align = "center", fig.asp = 0.62
)
knit_hooks$set(webgl = hook_webgl, rgl = hook_rgl)
```
 
```{r, include=FALSE}
inst = params$currentInstance
D <- read_csv("data/stat.csv")
carac <- filter(D,instance==inst,solved==1)

dat <- read_csv(paste("data/details/",inst,"_UB.csv",sep=""))
pts <- as.matrix(dat[,1:3])

dat2 <- read_csv(paste("data/details/",inst,"_coef.csv",sep=""))
coef <- as.matrix(dat2[,1:3])
nn <- count(dat2)[[1,1]]
```

[Return to main report](report.html)

# Instance caracteristics

```{r, echo = FALSE}
newtab <- slice( select(carac, instance, pb, n, p, coef, YN, ratioNDcoef) , 1)
newtab
```


# Non-dominated points

In the following plot, the non-dominated set is depicted according to the following rule :

* Red : supported extreme point
* Blue : supported non-extreme point
* Black : non-supported point

The convex hull of the non-dominated set is depicted by the gray surface.
 
```{r, webgl = TRUE, echo = FALSE}
#pts
#dat[1:3]

pts <- classifyNDSet(pts[,1:3])
pts[,1:3]

ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
  ylim = c(min(pts[,2])-2,max(pts[,2])+2),
  zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[!pts$sne,1:3], argsPlot3d = list(col = "black"))
plotPoints3D(pts[!pts$us,1:3], argsPlot3d = list(col = "blue"))
plotHull3D(pts[,1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)

finalize3D()
```

# Coefficient of the objective function

```{r, webgl = TRUE, echo = FALSE}

dat2[,1:3]
ini3D()
plotPoints3D(coef)
finalize3D()
```

# Preliminary tests

```{r,echo=FALSE}
perfPrelim <- filter(D,instance==inst,OB=="None")
Y <- perfPrelim[[12]][1]

datA <- read_csv(paste("data/details/UBrun/",inst,"_d_mof_-2_UB.csv",sep=""))
datB <- read_csv(paste("data/details/UBrun/",inst,"_b_mof_-2_UB.csv",sep=""))
datC <- read_csv(paste("data/details/UBrun/",inst,"_d_mfavg_-2_UB.csv",sep=""))
datD <- read_csv(paste("data/details/UBrun/",inst,"_b_mfavg_-2_UB.csv",sep=""))
    
    # depth-mof
    
    T <- filter(perfPrelim,nodesel=="depth",varsel=="mof")[[39]]
    st1 <- seq(0,T,by=T/99)
    val1 <- rep(0,100)
    for(i in 1:100){
      bidouille <- count(datA,time <= st1[i])
      bidouille <- filter(bidouille,bidouille[1]!=FALSE)
      if (count(bidouille) == 0) {
        numer <- 0
      }
      else{
        numer <- bidouille[[1,2]]
      }
      val1[i] <- 100*numer/Y
    }

    # breadth-mof
    
    perfPrelim <- filter(D,instance==inst)
    T <- perfPrelim %>% filter(nodesel=="breadth",varsel=="mof")
    T <- T[[39]]
    st2 <- seq(0,T,by=T/99)
    val2 <- rep(0,100)
    for(i in 1:100){
      bidouille <- count(datB,time <= st2[i])
      bidouille <- filter(bidouille,bidouille[1]!=FALSE)
      if (count(bidouille) == 0) {
        numer <- 0
      }
      else{
        numer <- bidouille[[1,2]]
      }
      val2[i] <- 100*numer/Y
    }
    
  # depth-mfavg
    
    perfPrelim <- filter(D,instance==inst)
    T <- perfPrelim %>% filter(nodesel=="depth",varsel=="mfavg")
    T <- T[[39]]
    st3 <- seq(0,T,by=T/99)
    val3 <- rep(0,100)
    for(i in 1:100){
      bidouille <- count(datC,time <= st3[i])
      bidouille <- filter(bidouille,bidouille[1]!=FALSE)
      if (count(bidouille) == 0) {
        numer <- 0
      }
      else{
        numer <- bidouille[[1,2]]
      }
      val3[i] <- 100*numer/Y
    }
    
    # breadth-mfavg
    
    perfPrelim <- filter(D,instance==inst)
    T <- perfPrelim %>% filter(nodesel=="breadth",varsel=="mfavg")
    T <- T[[39]]
    st4 <- seq(0,T,by=T/99)
    val4 <- rep(0,100)
    for(i in 1:100){
      bidouille <- count(datD,time <= st4[i])
      bidouille <- filter(bidouille,bidouille[1]!=FALSE)
      if (count(bidouille) == 0) {
        numer <- 0
      }
      else{
        numer <- bidouille[[1,2]]
      }
      val4[i] <- 100*numer/Y
    }
    
    
  pl <- tibble(x1=st1 , y1=val1 , x2=st2 , y2=val2 , x3=st3 , y3=val3 , x4=st4 , y4=val4)
  pl %>% ggplot() + geom_line(aes(x=x1,y=y1,colour="depth-mof")) + geom_line(aes(x=x2,y=y2,colour="breadth-mof")) + geom_line(aes(x=x3,y=y3,colour="depth-mfavg")) + geom_line(aes(x=x4,y=y4,colour="breadth-mfavg")) + xlab("Time (in sec)") + ylab("Proportion of non-dominated points found")

```


# Objective branching tests
