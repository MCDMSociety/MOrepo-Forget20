---
title: "`r params$new_title`"
author: "Nicolas Forget, Lars Relund Nielsen, Sune Lauth Gadegaard"
date: "`r Sys.Date()`"
output:
  html_document: 
    df_print: paged
    number_sections: false
    toc: yes
    theme: cosmo
    keep_md: false
    self_contained: true
editor_options: 
  chunk_output_cls: console
params:
  new_title: 'Results for instance '
  currentInstance: 'Forget20-AP_6_3_1-10_random_1_5'
---
 
```{r setup, include=FALSE}
#' Function for loading missing packages that install them if not already installed.
#'
#' @param packages String vector with package names
#'
#' @return NULL (invisible)
#' @export
#'
#' @examples loadPackages(c("MASS", "ggplot2", "tikzDevice"))
loadPackages <- function(packages) {
  newP <- packages[!(packages %in% installed.packages()[,"Package"])]
  if(length(newP)) install.packages(newP, repos = "http://cran.rstudio.com/")
  lapply(packages, library, character.only = TRUE)
  invisible(NULL)
}
loadPackages(c("tidyverse", "knitr", "rgl", "gMOIP", "rmarkdown", "fs"))
if (isTRUE(getOption('knitr.in.progress'))) options(rgl.useNULL=TRUE)
if (isTRUE(getOption('knitr.in.progress'))) options(rgl.printRglwidget = FALSE)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning=FALSE, message=FALSE, include = TRUE, 
  # cache = TRUE, autodep = TRUE, 
  echo=FALSE,
  rows.print = 12,
  out.width = "99%", 
  fig.width = 8, fig.align = "center", fig.asp = 0.62
)
knit_hooks$set(webgl = hook_webgl, rgl = hook_rgl)
```
 
```{r read data}
inst <- params$currentInstance
jsonFiles <- list.files("..", str_c(inst, "_.*.json"), full.names = T)
instFile <- list.files("../..", str_c(inst,".raw"), full.names = T, recursive = T)
datStat <- read_csv("../statistics.csv") %>% 
  dplyr::filter(instance == inst)
```

We consider instance (see [main](report.html) report for a description of statistics):

```{r}
datInput <- datStat %>% 
  distinct(instance, .keep_all = TRUE) %>% 
  select(instance, pb, n, p, coef, rangeC, ratioNDcoef)
datInput
```

The cofficients are generated using the `r datInput$coef` method and have a nondominated ratio of `r datInput$ratioNDcoef`:

```{r}
# read coef from instance
coefPoints <- read_delim(instFile, delim = " ", skip = 4, n_max = 3, col_names = F, trim_ws = T)[,1:datInput$n] %>% t() 
rownames(coefPoints) <- NULL
colnames(coefPoints) <- c("Z1", "Z2", "Z3")
coefPoints <- as_tibble(coefPoints)
view3d(zoom = 0.75)
ini3D()
plotPoints3D(coefPoints)
finalize3D()
rglwidget()
```

# Non-dominated points

All nondominated points were `r if (!any(datStat$solved)) "not"` found by one of the algorithm runs:

```{r}
id <- 1
if (any(datStat$solved)) id <- which(datStat$solved)[1]
mth <- paste0(datStat$nodesel[id], "_", datStat$varsel[id], "_", tolower(datStat$OB[id]))
fileN <- grep(str_c(inst, "_", mth, "_result.json"), jsonFiles, value = T)
if (!file.exists(fileN)) stop("File ", fileN, " cannot be found!")
lstRes <- jsonlite::fromJSON(fileN)
pts <- lstRes$points
view <- matrix( c(0.982128262519836, 0.179020717740059, -0.0581022650003433, 0, -0.0678737983107567, 0.0489457845687866, -0.996492624282837, 0, -0.17554897069931, 0.982626855373383, 0.0602218806743622, 0, 0, 0, 0, 1), nc = 4)
loadView(v = view, zoom = 0.75)
ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
    ylim = c(min(pts[,2])-2,max(pts[,2])+2),
    zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
if (nrow(pts) < 20) plotCones3D(pts[,1:3], rectangle = T, drawPoint = F, argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
plotPoints3D(pts[pts$type == "se",1:3], argsPlot3d = list(col = "red"))
plotPoints3D(pts[pts$type == "sne",1:3], argsPlot3d = list(col = "green"))
plotPoints3D(pts[pts$type == "us",1:3], argsPlot3d = list(col = "blue"))
plotHull3D(pts[,1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.25, color = "red"), useRGLBBox = TRUE)
finalize3D(argsAxes3d = list(edges = "bbox"))
rglwidget()
str <- ""
if (!any(datStat$solved)) str <- str_c("Solution for algorithm configuration ", mth, ".")
```

`r str` 

The nondominated set (`r nrow(pts)` points) is depicted using <span style="color:red">red</span> for supported extreme points, <span style="color:green">green</span> for supported non-extreme points and <span style="color:blue">blue</span> for unsupported points. The convex hull of the nondominated set is depicted by the light red surface and the dominance cones in lightblue.

# Algorithm results

Current algorithm configurations are tested:

```{r}
datStat %>% 
  select(instance, nodesel:OB, tpstotal)
```

Peformance plots (absolute and relative):

```{r}
# Add UB results
res <- NULL
for (i in 1:nrow(datStat)) {
  mth <- paste0(datStat$nodesel[i], "_", datStat$varsel[i], "_", tolower(datStat$OB[i]))
  fileN <- grep(str_c(inst, "_", mth, "_result.json"), jsonFiles, value = T)
  if (!file.exists(fileN)) stop("File ", fileN, " cannot be found!")
  lstRes <- jsonlite::fromJSON(fileN)
  res[[i]] <- lstRes$misc$outputStat$yNStat
}
datStat <- datStat %>% 
  mutate(resUB = res) %>% 
  mutate(relativeSolved = 
    pmap(list(resUB, tpstotal, str_c(nodesel, "_", varsel, "_", tolower(OB))), 
         function(df = ..1, cpuT = ..2, mth = ..3) {
            if (nrow(df) > 1) {
               res <- tibble(mth = mth, pct = c(nrow(df), rep(nrow(df), nrow(df)), nrow(df)), cpu = c(0, df$time, cpuT), rowname = 1:(nrow(df)+2))
               res <- res %>% mutate(pct = (rowname-1)/pct) %>% select(-rowname)
               res[nrow(res),"pct"] <- 1
               res <- bind_rows(res, tibble(mth = mth, pct = res$pct[1:(nrow(res)-1)], cpu = res$cpu[2:nrow(res)])) %>% arrange(pct, cpu)
            } else {
               res <- tibble(mth = mth, pct = c(1, 1), cpu = c(df$time, cpuT), rowname = 1:2)
            }
            res %>% mutate(pctCpu = cpu/cpuT)
          }))

res <- datStat %>% select(relativeSolved) %>% unnest(relativeSolved)
height <- if_else(max(res$cpu) < 10, 0, 0.01)
ggplot(aes(x = cpu, y = pct, color = mth), data = res ) + # | mth == "depth_mof_none" %>% filter(mth == "depth_mof_exact")
  geom_line() + geom_jitter(size = 0.9, width = 0, height = height) +
  # geom_point(data = res %>% group_by(mth) %>% summarise_at(vars(c('pct','cpu')), max)) +
  xlab("CPU time (in sec)") + ylab("Proportion of nondominated points found") + 
  theme(legend.position="bottom", legend.title=element_blank()) 

ggplot(aes(x = pctCpu, y = pct, color = mth), data = res) + 
  geom_line() + geom_jitter(size = 0.9, width = 0, height = height) +
  xlab("Relative CPU time (all stop in 1)") + ylab("Proportion of nondominated points found") + 
  theme(legend.position="bottom", legend.title=element_blank()) 
```

Animation of best and worse algorithm configuration:

```{r movie ini, eval=FALSE}
options(rgl.useNULL=FALSE)
par3d("windowRect"= c(10,50,1010,1050))
view <- matrix( c(0.82544869184494, -0.418245762586594, -0.379084706306458, 0, 
                    -0.403665781021118, 0.0320594720542431, -0.914344727993011, 0, 
                    0.394574046134949, 0.907767832279205, -0.142367839813232, 0, 
                    0, 0, 0, 1), nc = 4)
loadView(v = view, zoom = 0.75)
ini3D()
axes3d()
rgl.close()
```
```{r movie, include=FALSE, eval=FALSE}
#' Create a gif and mkv movie of how the non-dominated points are found.
#'
#' @param pts The non-dominated points with node, depth and time info.
#' @param cpuTotal Total cpu run time.
#' @param duration Total duration of the movie.
#' @param add Extra percentage to add total frames (1/2 in the start and end).
#' @param filePrefix File prefix.
#' @param dir Temp dir for images.
#' @param checkGif Only generate info no gif already generated.
#'
#' @return System call.
createMovie <- function(pts, cpuTotal, duration = 40, add = 0.1, filePrefix = "movie", dir = str_c("tmp_", filePrefix), checkGif = TRUE) {
  if (checkGif) {
    if (file_exists(str_c("instances/", filePrefix, ".gif"))) return(invisible(NULL))
  }
  
  dir_create(dir)
  olddir <- setwd(dir)
  # par3d(skipRedraw = TRUE) # stops intermediate redraws
  # on.exit(par3d(skipRedraw = FALSE)) # redraw at the end
  
  # if (!genPng) {
  #   frames <- length(list.files(path=".", pattern = '*.png'))
  #   frameRate <- frames/duration
  #   cat("\nGenerate ", filePrefix, ".mkv:\n", sep="")
  #   system(str_c("ffmpeg -y -framerate ", frameRate, " -i ", filePrefix, "%05d.png -c:v copy ", filePrefix, ".mkv"))
  #   cat("\nGenerate ", filePrefix, ".gif:\n", sep="")
  #   cat("ffmpeg -y -i ", filePrefix, ".mkv -vf \"fps=10,scale=1000:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\" -loop 0 ", filePrefix, ".gif\n", sep = "")
  #   system(str_c("ffmpeg -y -i ", filePrefix, ".mkv -vf \"fps=10,scale=1000:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\" -loop 0 ", filePrefix, ".gif"))
  #   return(invisible(NULL))
  # }
  
  dublicateFile <- function(i, to) {
    if (i >= to) return(i <- i + 1)
    # cat("  Start file dublicate ... ")
    fN <- sprintf("%s%05d.png", filePrefix, i)
    for (k in (i+1):to) {
      file.copy(fN, sprintf("%s%05d.png", filePrefix, k))
    }
    # cat("finished\n")
    return(i <- to + 1)
  }
  
  # use node as frame ids
  frames <- round((1 + add)*max(pts$node),0)
  framesS <- round(add*max(pts$node)/2,0)  # start frames
  pts <- full_join(pts, classifyNDSet(pts[,1:3])) %>% 
  as_tibble() %>% 
  mutate(colP = case_when(
    cls == "se" ~ "red",
    cls == "sne" ~ "green",
    cls == "us" ~ "blue",
    TRUE ~ "gray"), 
    frame = node + framesS) 
  
  # first frame
  cat("Frame 1/", frames, "\n", sep = "")
  par3d("windowRect"= c(10,50,1010,1050))
  view <- matrix( c(0.82544869184494, -0.418245762586594, -0.379084706306458, 0, 
                    -0.403665781021118, 0.0320594720542431, -0.914344727993011, 0, 
                    0.394574046134949, 0.907767832279205, -0.142367839813232, 0, 
                    0, 0, 0, 1), nc = 4)
  loadView(v = view, zoom = 0.75)
  ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
      ylim = c(min(pts[,2])-2,max(pts[,2])+2),
      zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
  axes3d()
  # title3d(main = str_c("Nondominated points generated over time (", filePrefix, ")"))
  i <- 1 # file numbering
  rgl.snapshot(filename = sprintf("%s%05d.png", filePrefix, i), fmt = "png"); 
  j <- 1 # row index
  i <- dublicateFile(i, pts$frame[j]-1)
  repeat {
    if (j > nrow(pts)) break
    cat("Frame ", i, "/", frames, "\n", sep = "")
    tmp <- pts %>% dplyr::filter(frame == pts$frame[j])
    for (s in unique(tmp$cls)) {
      tmp1 <- tmp %>% dplyr::filter(cls == s)
      plotCones3D(tmp1[, 1:3], argsPlot3d = list(col = tmp1$colP[1]), rectangle = T,
                argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
    }
    rgl.snapshot(filename = sprintf("%s%05d.png", filePrefix, i), fmt = "png");
    j <- j + nrow(tmp)
    if (j > nrow(pts)) {i <- i + 1; break}
    i <- dublicateFile(i, pts$frame[j]-1)
  }
  # last frames
  plotHull3D(pts[,1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)
  rgl.snapshot(filename = sprintf("%s%05d.png", filePrefix, i), fmt = "png")
  rgl.close()
  i <- dublicateFile(i, frames)
  # gen output
  frameRate <- i/duration
  cat("\nGenerate ", filePrefix, ".mkv:\n", sep="")
  system(str_c("ffmpeg -y -framerate ", frameRate, " -i ", filePrefix, "%05d.png -c:v copy ", filePrefix, ".mkv"))
  cat("\nGenerate ", filePrefix, ".gif:\n", sep="")
  cat("ffmpeg -y -i ", filePrefix, ".mkv -vf \"fps=10,scale=1000:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\" -loop 0 ", filePrefix, ".gif\n", sep = "")
  system(str_c("ffmpeg -y -i ", filePrefix, ".mkv -vf \"fps=10,scale=1000:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\" -loop 0 ", filePrefix, ".gif"))
  # file.rename(str_c(filePrefix, ".mkv"), str_c("../", filePrefix, ".mkv"))
  file.rename(str_c(filePrefix, ".gif"), str_c("../instances/", filePrefix, ".gif"))
  setwd(olddir)
  dir_delete(dir)
}

gifFiles <- NULL
fct <- 30/mean(datStat$tpstotal) # mean movie time is 30 sec
for (i in 1:nrow(datStat)) {
  pfx <- paste0(datStat$instance[i], "_", datStat$nodesel[i], "_", datStat$varsel[i], "_", tolower(datStat$OB[i]))
  pts <- datStat$resUB[[i]]
  createMovie(pts, datStat$tpstotal[i], duration = fct*datStat$tpstotal[i],  filePrefix = pfx, checkGif = T)
  gifFiles <- c(gifFiles, str_c("instances/", pfx, ".gif"))
}
```
```{r gif images old, eval = FALSE}
out <- ""
for (s in gifFiles) {
  out <- str_c(out, " ![alt-text-1](", s, ")")
}
```
```{r gif images, results='hide', eval=FALSE}
titleN <- str_replace_all(gifFiles, '(^.*)_(.*?_.*?_.*?)(.gif$)', '\\2')
i <- 1
out <- "  |  \n------------- | -------------\n"
for (r in 1:ceiling(length(gifFiles)/2)) {  # two cols
  if (i > length(gifFiles)) break
  out <- str_c(out, titleN[i], " ![", gifFiles[i], "](", gifFiles[i], ") | ")
  i <- i + 1
  if (i > length(gifFiles)) break
  out <- str_c(out, titleN[i], " ![", gifFiles[i], "](", gifFiles[i], ")\n")
  i <- i + 1
}
```
```{r slider}  
# out.height=1000
dat <- datStat %>% filter(rank(tpstotal, ties.method="random")==1 | rank(tpstotal, ties.method="random")==n())
#%>% group_by(nodesel) 
# dat <- bind_rows(top_n(dat, 1, tpstotal), top_n(dat, -1, tpstotal))   
ptsLst <- vector("list", nrow(dat))
for (i in 1:nrow(dat)) {
  ptsLst[[i]]$pts <- dat$resUB[[i]]
  ptsLst[[i]]$mth <- paste0(dat$nodesel[i], "_", dat$varsel[i], "_", tolower(dat$OB[i]))
  ptsLst[[i]]$cpu <- dat$tpstotal[i]
 }
loadView(v = view, zoom = 0.75)
limits <- lapply(ptsLst, function(x) {
   tmp <- rbind(apply(x$pts[,c('z1', 'z2', 'z3')], 2, min),
         apply(x$pts[,c('z1', 'z2', 'z3')], 2, max))
})
limits <- limits %>% reduce(rbind)
limits <- rbind(apply(limits, 2, min),
      apply(limits, 2, max))
steps <- 1000
stepLgt <- max(sapply(ptsLst, function(x) {x$cpu}))/steps #  max(max(sapply(ptsLst, function(x) {max(x[,'time'])})))/steps
limits[1,] <- limits[1,] - 2
limits[2,] <- limits[2,] + 2
res <- vector("list", length(ptsLst))
mfrow3d(ceiling(length(ptsLst)/2), 2, sharedMouse = T)
for (s in 1:length(ptsLst)) {
   next3d()
   ini3D(argsPlot3d = list(
      xlim = c(limits[1,'z1'], limits[2,'z1']),
      ylim = c(limits[1,'z2'], limits[2,'z2']),
      zlim = c(limits[1,'z3'], limits[2,'z3'])),
      clear = F
   )
   axes3d()
   title3d(main = ptsLst[[s]]$mth)
   emptyId <- min(rgl.ids()$id)
   pltCones <- nrow(ptsLst[[s]]$pts) < 20
   lst <- as.vector(rep(emptyId, steps+1), "list")
   for (j in 1:nrow(ptsLst[[s]]$pts)) {
      i <- min(ceiling(ptsLst[[s]]$pts$time[j]/stepLgt), steps)
      if (pltCones) {
         ids <- plotCones3D(ptsLst[[s]]$pts[j, 1:3], rectangle = T, drawPoint = T, argsPolygon3d = list(alpha = 1, color = "blue"), drawLines = T)
      } else ids <- plotPoints3D(ptsLst[[s]]$pts[j, 1:3])
      if (any(lst[[i]] == emptyId)) lst[[i]] <- ids else lst[[i]] <- c(lst[[i]], ids)
   }
   names(lst) <- paste0("cone", 1:length(lst))
   i <- max(1, min(ceiling(ptsLst[[s]]$cpu/stepLgt), steps))
   lst[[i]] <- plotHull3D(ptsLst[[s]]$pts[,1:3], addRays = T, argsPolygon3d = list(alpha = 0.25, color = "red"), useRGLBBox = TRUE)$ids
   # res[[s]]$lst <- lst
   res[[s]] <- subsetControl(subsets = lst, accumulate = T, subscenes = subsceneInfo()$id)
}
rglwidget() %>%
playwidget(res,
   start = 0, stop = steps, interval = 0.05, rate = 33, loop = F,
   components = c("Play", "Slower", "Faster", "Reset", "Slider"))
```

```{r, include=FALSE}
rgl.close()
```


## All statistics

```{r}
datStat
```





[Return to main report](report.html)


```{r testing, eval = FALSE}
library(rgl)

time <- 0:500
xyz <- cbind(cos(time/20), sin(time/10), time)
lineid <- plot3d(xyz, type="l", col = "black")["data"]
sphereid <- spheres3d(xyz[1, , drop=FALSE], radius = 8, col = "red")
rglwidget() %>%
playwidget(list(
  ageControl(births = time, ages = c(0, 0, 50),
		colors = c("gray", "red", "gray"), objids = lineid),
  ageControl(births = 0, ages = time,
		vertices = xyz, objids = sphereid)),
  start = 0, stop = max(time) + 20, rate = 50,
  components = c("Reverse", "Play", "Slower", "Faster",
                 "Reset", "Slider", "Label"),
  loop = TRUE)



xyz <- pts
plot3d(pts[,1:3], type = "n")
sphereid <- spheres3d(pts[1, 1:3, drop=FALSE], radius = 8, col = "red")
rglwidget() %>%
playwidget(list(
  ageControl(births = 0, ages = 1:nrow(pts),
		vertices = xyz[,1:3], objids = sphereid)),
  start = 0, stop = nrow(pts) + 20, rate = 5,
  components = c("Reverse", "Play", "Slower", "Faster",
                 "Reset", "Slider", "Label"),
  loop = TRUE)


objid <- plot3d(pts[,1:3], type = "p", alpha = 0)["data"]
# sphereid <- spheres3d(pts[1, 1:3, drop=FALSE], radius = 1, alpha = 1)
control <- ageControl(
           value=1,
           births = pts$time,
           ages = pts$time,
           # vertices = pts[,1:3],
           alpha = rep(1, nrow(pts)),
           color = rep("red", nrow(pts)),
           objids = objid)
rglwidget(height = 300, width = 300) %>%
playwidget(control, start = 0, stop = max(pts$time) + 1, step = 0.01,
         rate = 0.5)



# i = 1
# pts <- datStat$resUB[[i]]
# pts <- full_join(pts, classifyNDSet(pts[,1:3])) %>% 
#   as_tibble() %>% 
#   mutate(colP = case_when(
#     cls == "se" ~ "red",
#     cls == "sne" ~ "green",
#     cls == "us" ~ "blue",
#     TRUE ~ "gray"))
# cpuT <- datStat$tpstotal[i]
# ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
#     ylim = c(min(pts[,2])-2,max(pts[,2])+2),
#     zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
# axes3d()
# for (j in 1:nrow(pts)) {
#   if (pts$cls[j] == "se") colP <- "red"
#   else if (pts$cls[j] == "sne") colP <- "green"
#   else if (pts$cls[j] == "us") colP <- "blue"
#   else colP <- "gray"
#   plotCones3D(pts[j, 1:3], argsPlot3d = list(col = colP), rectangle = T, argsPolygon3d = list(alpha = 1, color = "lightblue"))
#   # Sys.sleep(5*pts$time/cpuT)
# }
# plotHull3D(pts[,1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)





# 
# view <- matrix( c(0.82544869184494, -0.418245762586594, -0.379084706306458, 0, -0.403665781021118, 0.0320594720542431, -0.914344727993011, 0, 0.394574046134949, 0.907767832279205, -0.142367839813232, 0, 0, 0, 0, 1), nc = 4)
# loadView(v = view)
# ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
#     ylim = c(min(pts[,2])-2,max(pts[,2])+2),
#     zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
# axes3d()
# spin <- spin3d(axis = c(0, 0, 0.5), rpm = 4) # the scene spinner
# j <- 1
# f <- function(time) {
#     par3d(skipRedraw = TRUE) # stops intermediate redraws
#     on.exit(par3d(skipRedraw = FALSE)) # redraw at the end
#     # rgl.pop(id = spriteid) # delete the old sprite
#     if (j <= nrow(pts)) {
#       tmp <- pts %>% dplyr::filter(node == pts$node[j])
#       tmp1 <- tmp %>% dplyr::filter(se)
#       if (nrow(tmp1) > 0) plotCones3D(tmp1[, 1:3], argsPlot3d = list(col = "red"), rectangle = T, 
#                   argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
#       tmp1 <- tmp %>% dplyr::filter(sne)
#       if (nrow(tmp1) > 0) plotCones3D(tmp1[, 1:3], argsPlot3d = list(col = "blue"), rectangle = T, 
#                   argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
#       tmp1 <- tmp %>% dplyr::filter(us)
#       if (nrow(tmp1) > 0) plotCones3D(tmp1[, 1:3], argsPlot3d = list(col = "green"), rectangle = T, 
#                   argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
#       # for (k in 1:nrow(tmp)) {
#       #   plotCones3D(tmp[k, 1:3], argsPlot3d = list(col = tmp$colP[k]), rectangle = T, 
#       #               argsPolygon3d = list(alpha = 1, color = "lightblue"), drawLines = F)
#       # }
#       j <<- j + nrow(tmp)
#     }
#     else if (j == nrow(pts) + 1) {
#       plotHull3D(pts[,1:3], addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)
#       j <<- j + 1
#     }
#     else
#       return(spin(time))
#     Sys.sleep(1)
#     spin(0)
# }
# fps <- 10
# dur <- ceiling(nrow(pts)/fps) + 15
# play3d(f, duration = dur)
# # movie3d(f, dir = ".", duration = dur, fps = fps, movie = str_c("test"))

# Spin one object
open3d()
plot3d(oh3d(col = "lightblue", alpha = 0.5))
play3d(spin3d(axis = c(1, 0, 0), rpm = 30), duration = 2)

# Show spinning sprites, and rotate the whole view
open3d()
spriteid <- NULL

spin1 <- spin3d(rpm = 4.5 ) # the scene spinner
spin2 <- spin3d(rpm = 9 ) # the sprite spinner

f <- function(time) {
    par3d(skipRedraw = TRUE) # stops intermediate redraws
    on.exit(par3d(skipRedraw = FALSE)) # redraw at the end

    rgl.pop(id = spriteid) # delete the old sprite
    cubeid <- shade3d(cube3d(), col = "red")
    spriteid <<- sprites3d(0:1, 0:1, 0:1, shape = cubeid,
                   userMatrix = spin2(time, 
                     base = spin1(time)$userMatrix)$userMatrix)
    spin1(time)
}
play3d(f, duration = 2)





library(magick)

labels<-as.character(unique(dnd$predclass))
frames <- length(labels)

for (i in 1:frames) {
  name<- paste('00',i,'plot.png', sep='')
  png(name)
  plot.new()
  sp3d<-scatterplot3d(x =dnd$AC, y = dnd$Con, z = dnd$HP, color="darkgrey", type="h",pch=16,angle=30)
  sp3d
  sp3d$points3d(dnd[dnd$predclass==labels[i],c("AC")],dnd[dnd$predclass==labels[i],c("Con")],dnd[dnd$predclass==labels[i],c("HP")],col="red", type="h", pch=16)
  legend(sp3d$xyz.convert(41, 3, 310),legend =c(labels[i],paste0("Non-",labels[i])), col =c("darkgrey","red"), pch = 16)
  dev.off()
}

list.files(path=".", pattern = '*.png', full.names = TRUE) %>% 
  image_read() %>% 
  image_join() %>% 
  image_animate(fps=4) %>% 
  image_write("dnd_classes.gif")
```

