---
title: "Preliminary results"
output:
  html_document: 
    df_print: paged
    number_sections: yes
    toc: yes
    theme: cosmo
    self_contained: true
editor_options: 
  chunk_output_type: console
---

<!-- 
NOTE if you experience problems with files in Dropbox it may help to disable DB sync while working
on the files!

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor
inside it and pressing *Ctrl+Shift+Enter*.

Help: See Help -> Markdown Quick Reference or Help -> Cheetsheets

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.
When you save the notebook, an HTML file containing the code and output will be saved alongside it
(click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike
*Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last
run in the editor is displayed.
-->

```{r setup, include=FALSE}
#' Function for loading missing packages that install them if not already installed.
#'
#' @param packages String vector with package names
#'
#' @return NULL (invisible)
#' @export
#'
#' @examples loadPackages(c("MASS", "ggplot2", "tikzDevice"))
loadPackages <- function(packages) {
  newP <- packages[!(packages %in% installed.packages()[,"Package"])]
  if(length(newP)) install.packages(newP, repos = "http://cran.rstudio.com/")
  lapply(packages, library, character.only = TRUE)
  invisible(NULL)
}
loadPackages(c("tidyverse", "knitr", "rgl", "gMOIP", "rmarkdown","ggplot2"))

library(knitr)
library(rgl)
options(rgl.useNULL=TRUE)
options(rgl.printRglwidget=FALSE)
rgl::setupKnitr()
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning=FALSE, message=FALSE, include = TRUE, 
  cache = TRUE, autodep = TRUE,
  out.width = "99%", fig.width = 8, fig.align = "center", fig.asp = 0.62
)
knit_hooks$set(webgl = hook_webgl, rgl = hook_rgl)




# Generation of stat for preliminary tests

  # Table for avg times

    gen_table_times <- function(tab){
      
      t <- tab %>%
        group_by(pb,n,varsel,nodesel) %>%
          summarize(avg = mean(tpstotal))

      t <- pivot_wider(t,names_from = nodesel, values_from = avg)
      t <- pivot_wider(t,names_from = varsel, values_from = c("breadth","depth"))
      t
    }
    
  # Plot of avg times
    
    gen_plot_times <- function(tab){
      
      t <- tab %>%
        group_by(pb,n,varsel,nodesel) %>%
          summarize(avg = mean(tpstotal))
      t <- pivot_wider(t,names_from = nodesel, values_from = avg)
      t <- pivot_wider(t,names_from = varsel, values_from = c("breadth","depth"))
      
      t %>% ggplot( aes(x=n)) + geom_line(aes(y=breadth_mfavg,colour="breadth-mfavg")) + geom_line(aes(y=depth_mfavg,colour="depth_mfavg")) + geom_line(aes(y=breadth_mof,colour="breadth_mof")) + geom_line(aes(y=depth_mof,colour="depth_mof")) + ylab("average time (sec)") + xlab("Number of variables") + ggtitle("Average computational time")
    }
    
  # Tables for nb nodes
    
    gen_table_nodes <- function(tab){
      
      t <- tab %>%
        group_by(pb,n,varsel,nodesel) %>%
          summarize(avg = mean(nbnodes))

      t <- pivot_wider(t,names_from = nodesel, values_from = avg)
      t <- pivot_wider(t,names_from = varsel, values_from = c("breadth","depth"))
      t
    }

  # Plot for nb nodes
    
    gen_plot_nodes <- function(tab){
      
      t <- tab %>%
        group_by(pb,n,varsel,nodesel) %>%
          summarize(avg = mean(nbnodes))
      t <- pivot_wider(t,names_from = nodesel, values_from = avg)
      t <- pivot_wider(t,names_from = varsel, values_from = c("breadth","depth"))
      
      t %>% ggplot( aes(x=n)) + geom_line(aes(y=breadth_mfavg,colour="breadth-mfavg")) + geom_line(aes(y=depth_mfavg,colour="depth_mfavg")) + geom_line(aes(y=breadth_mof,colour="breadth_mof")) + geom_line(aes(y=depth_mof,colour="depth_mof")) + ylab("Number of nodes") + xlab("Number of variables") + ggtitle("Average number of nodes explored")
    }
    
# Coefficient analysis
    
    # Plot relation Cn - |YN|
    
    gen_plot_correl_coef <- function(dat,pbb){
      
      datcoef <- filter(dat,solved==1,pb==pbb)
      datcoef <- distinct(datcoef,instance,.keep_all = TRUE)

      datcoef %>% ggplot( aes(x=YN , y=ratioNDcoef, colour=n)) + geom_point() +     ggtitle("Relation between the number of non-dominated coefficients and |YN|")
    }
    
    # Plot complexity per range
    
    gen_plot_range <- function(dat,pbb,coeff){
      
      datcoef <- filter(dat,solved==1,pb==pbb,coef==coeff)
      datcoef <- distinct(datcoef,instance,.keep_all = TRUE)
      
      datcoef <- datcoef %>% group_by(n,rangemin,rangemax) %>% summarise(avg = mean(YN))
      plt <- datcoef %>% ggplot(aes(x=n , y=avg, group=interaction(rangemin,rangemax) , colour=interaction(rangemin,rangemax))) + geom_line() + xlab("Number of variables") + ylab("Average size of YN") + ggtitle(paste("Tri-objective",pbb,"problems with",coeff,"generation for the coefficients"))
      show(plt)
    }
    
    gen_plot_range_full <- function(dat,pbb,coeff){
      
      datcoef <- filter(dat,solved==1,pb==pbb,coef==coeff)
      datcoef <- distinct(datcoef,instance,.keep_all = TRUE)
      
      datcoef %>% ggplot(aes(x=n, y=YN, group=interaction(rangemin,rangemax), colour=interaction(rangemin,rangemax))) + geom_point() + xlab("Number of variables") + ylab("Average size of YN") + ggtitle(paste("Tri-objective",pbb,"problems with",coeff,"generation for the coefficients"))
    }
    
    # Plot complexity per coef
    
    gen_plot_coef <- function(dat,pbb,rmin,rmax){
      
      datcoef <- filter(dat, solved==1, pb==pbb, rangemin==rmin, rangemax==rmax)
      datcoef <- distinct(datcoef,instance,.keep_all = TRUE)
      
      datcoef <- datcoef %>% group_by(n,coef) %>% summarise(avg = mean(YN))
      plt <- datcoef %>% ggplot(aes(x=n , y=avg, group=coef , colour=coef)) + geom_line() + xlab("Number of variables") + ylab("Average size of YN") +  ggtitle(paste("Tri-objective",pbb,"problems with coefficients in the range [",rmin,",",rmax,"]"))
      show(plt)
    }

```

All the problems are in minimization here, i.e. if an objective function $z(x)$ is actually in maximisation, we will minimise $-z(x)$ instead. Only binary variables are considered here.



# Instances

[An explanation of instances and instance names (as in the ReadMe file)]

List of test instances.

[Go to instance example](instance.html, cache=FALSE)

```{r instance table, echo=FALSE}
dat <- read_csv("../convert/data/stat.csv")
#dat <- filter(dat)

sh <- distinct(dat,instance,.keep_all = TRUE)
select(sh, instance, pb, n, p, coef,rangemin,rangemax)
```

Several methods for generating the coefficient of the objective functions are tested here. This is given by the column coef.

* random : the coefficient are generated randomly in the inerval [a,b]
* spheredown : the coefficient are generated on the non-dominated part of a sphere in minimisation in the interval [a,b]
* sphereup : the coefficient are generated on the non-dominated part of a sphere in maximisation in the interval [a,b]
* 2box : the coefficients are generated randomly in two small boxes of R^3



# Input and output statistics

A set of statistics are stored for each instance and algorithm run.

## Input statistics

For each instance we have statistics:
  
  - Problem class (PC): 
  - $n$: Number of variables.
  - $p$: Number of objectives.
  - `rangeC`: The range the objective coefficients are generated within.
  - `rangeO[i]`: The range of objective $i$ found by setting the variables to the worst/best value. 
  - `coef`: 
  - `ratioND`: 
  - ???


## Output statistics

For each algorithm run we have statistics:

  - `cpu`: Cpu time.
  - ... [Add all output statistics]




# Research questions

The first purpose of this study is to learn how some components of the branch and bound influences the behaviour of the algorithm it terms of *computational time* (expressed in seconds everywhere) and in term of *number of nodes explored* (i.e. how much nodes are developed in the branch and bound tree before the algorithm ends).

The branch and bound algorithm will always use the linear relaxation as lower bound set and the incumbent set as upper bound set. At each nodes, the extreme points of the lower bound set are checked for integrality and possibly added to the upper bound set. The components that will vary are:

* the node selection : in the multi-objective branch and bound literature, depth first strategies are (almost) always used and are considered as better strategies than breadth first. However, our conjecture is that if a problem with an "easy" single-objective version is solved, then many non-dominated points may be found in a node close to the root node, in the early stages of the tree. Hence, using a breadth first strategy may provide a better upper bound set earlier in the algorithm, as a larger number of points are expected to be found shallow in the tree while only a few points can be found at each node deep in the tree (1 maximum at a leaf node for example). However, it is not clear to see what is the actual impact. Hence, here comes the first research question : **how does depth and breadth first strategies affects the behaviour of the algorithm ?** (computational time, number of nodes explored)

* the variable selection : to the best of our knowledge, no extensive study for variable selection has been conducted in the literature. Sometimes, this component is even not mentioned. As it is not the main purpose of this study, only two rules that rely on the caracteristics of the lower bound set will be tested here.

  + mof : Most Often Fractional. The branching is operated on the variable that is the most often fractional among the extreme points of the lower bound set.
  
  + mfavg : Most Fractional in AVeraGe. The branching is operated on the variable such that its average value among the extreme points of the lower bound set is the most fractional, i.e. the closest to 0.5.
  
* the branching scheme : in a regular branch and bound, branching is operated (i.e. sub-problems are created) in the decision space. In the bi-objective case, it has been shown that creating additional sub-problems in the objective space (procedure called objective branching in this study) leads to better computational times. A new research question arises here : **what is the impact of objective branching on a branch and bound algorithm for solving problems with three objectives ?** In order to address that, three versions of the branch and bound will be tested (with the best node and variable selection previously identified for each problem configuration):

  + None : no objective branching is performed. Hence, this version is just a regular branch and bound.
  
  + exact : objective branching is performed using the algorithm from [master thesis paper].
  
  + unique cone : a unique sub-problem is created at each node. In this case, objective branching is applied on the nadir point of the local upper bounds dominated by the lower bound set. See [master thesis paper] for more details.
  

The second purpose of this study is to learn how the caracteristics of an instance can affect its difficulty. The difficulty will be here mesured by the *size of the non-dominated set*, and the *computational time* required to solve the instance. The computational time will be determined using the branch and bound algorithm previously described. Note that the complexity of an objective space search algorithm is positively correlated to the size of the non-dominated set as the more non-dominated there are, the more integer programs have to be solved.

The focus will be here on the objective function coefficients. The first research question here is: **does the range of the objective function coefficient has an impact on the difficulty of the problem ?**. In order to answer that, three different ranges will be tested:

* $[1,10]$ : a small range of values.
* $[1,1000]$ : a large range of values
* $[1000,2000]$ : a large range of values, but shifted to larger values.

For the facility location problems, two sets of costs (i.e. coefficients of objective function) can be identified: the assignment costs ($c_{ij}$) and the facility opening costs ($f_j$). It is reasonable to assume that these two sets of costs may not take their values in the same range. Let the assignment costs take their values in $[a,b]$, the generation of the facility opening costs will be divided into two categories of instances:

* facility location easy : $f_j \in [b+1,a+b]$. It is called "easy" because it seems that having high facility opening costs makes the problem easier (see later in the study).
* facility location hard : $f_j \in [0.1a,0.1b]$. It is called "hard" because it seems that having small facility opening costs makes the problem harded (see later in the study).

The second research question related to that topic is: **does the method used to generate the coefficients of the objective function has an impact on the difficulty of the problem ?**. Indeed, the usual procedure to generate objective function is to generate the coefficients randomly in a given range $[a,b]$. However, one could imagine other way to generate coefficient. Four methods will be studied here.

* random : the coefficient are generated randomly with a uniform distribution in the range $[a,b]$. For three objectives, random generated coefficients looks as follows.

```{r, webgl = TRUE, echo = FALSE}

range <- matrix(c(1,100, 50,100, 10,50), ncol = 2, byrow = TRUE )
ini3D()
pts <- genSample(3, 1000, range = range, random = TRUE)
plotPoints3D(pts)
finalize3D()
```

* sphere down : the coefficients are generated on the lower part of a sphere (see next picture). Note that the sphere is adjusted such that the coefficients are in the range $[a,b]$, i.e. the sphere is not necessarily included in $[a,b]^p$.

```{r, webgl = TRUE, echo = FALSE, cache=FALSE}

cent <- c(1000,1000,1000)
r <- 750
planeC <- c(cent-r/3)
planeC <- c(planeC, -sum(planeC^2))
pts <- genSample(3, 500,
  argsSphere = list(center = cent, radius = r, below = TRUE, plane = planeC, factor = 6))

ini3D()
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(planeC[1],planeC[2],planeC[3],planeC[4], alpha = 0.5, col = "red")
finalize3D()
```

* sphere up : the coefficients are generated on the upper part of a sphere (see next picture). Note that the sphere is adjusted such that the coefficients are in the range $[a,b]$, i.e. the sphere is not necessarily included in $[a,b]^p$.

```{r, webgl = TRUE, echo = FALSE, cache=FALSE}

cent <- c(1000,1000,1000)
r <- 750
planeC <- c(cent+r/3)
planeC <- c(planeC, -sum(planeC^2))
pts <- genSample(3, 500,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))

ini3D()
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(planeC[1],planeC[2],planeC[3],planeC[4], alpha = 0.5, col = "red")
finalize3D()
```

* 2box : the coefficients are generated randomly but in two specific parts of $[a,b]^p$ (see next picture).

```{r, webgl = TRUE, echo = FALSE, cache=FALSE}

range <- matrix(c(1,1000, 1,1000, 1,1000), ncol = 2, byrow = TRUE )
ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts <- genSample(3, 300, range = range, box = TRUE)
plotPoints3D(pts)
finalize3D()
```




# Preliminary tests CPU time

Here are tested different combinations of variable and node selection for the basic branch and bound. In the following :

* depth = depth first strategy for node selection. The last node created is the first explored.
* breadth = breadth first strategy for node selection. The first node created is the first explored.
* mof = Most Often Fractional strategy for variable selection. Branching is operated on the variable that is the most often fractional among the extreme points of the lower bound set.
* mfavg = Most Fractional in AVeraGe strategy for variable selection Branching is operated on the variable that is the most fractional (i.e. the closest to 0.5) in average among the extreme points of the lower bound set.


## Random coefficient generation

```{r, echo=FALSE}
coeff <- "random"
```
The coefficient are generated using the `r coeff` method.

### Range : [1,10]

```{r, echo=FALSE}
rmin <- 1
rmax <- 10

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1,1000]

```{r, echo=FALSE}
rmin <- 1
rmax <- 1000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1000,2000]

```{r, echo=FALSE}
rmin <- 1000
rmax <- 2000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```




## Sphere Down coefficient generation

```{r, echo=FALSE}
coeff <- "spheredown"
```
The coefficient are generated using the `r coeff` method.

### Range : [1,10]

```{r, echo=FALSE}
rmin <- 1
rmax <- 10

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1,1000]

```{r, echo=FALSE}
rmin <- 1
rmax <- 1000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1000,2000]

```{r, echo=FALSE}
rmin <- 1000
rmax <- 2000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```



## Sphere Up coefficient generation

```{r, echo=FALSE}
coeff <- "sphereup"
```
The coefficient are generated using the `r coeff` method.

### Range : [1,10]

```{r, echo=FALSE}
rmin <- 1
rmax <- 10

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1,1000]

```{r, echo=FALSE}
rmin <- 1
rmax <- 1000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1000,2000]

```{r, echo=FALSE}
rmin <- 1000
rmax <- 2000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```




## Two boxes coefficient generation

```{r, echo=FALSE}
coeff <- "random"
```
The coefficient are generated using the `r coeff` method.

### Range : [1,10]

```{r, echo=FALSE}
rmin <- 1
rmax <- 10

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1,1000]

```{r, echo=FALSE}
rmin <- 1
rmax <- 1000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```


### Range : [1000,2000]

```{r, echo=FALSE}
rmin <- 1000
rmax <- 2000

```
The coefficient of the objective functions are in the range [`r rmin`,`r rmax`].

#### Knapsack

Knapsack problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "KP",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Assignment

Assignment problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "AS",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location easy

Easy facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLe",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```

#### Facility location hard

Hard facility location problems are studied here. The table below shows the average computational times in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

tab <- filter(dat,OB == "None",pb == "FLh",coef == coeff,rangemin == rmin,rangemax == rmax)

gen_table_times(tab)
gen_plot_times(tab)

```

The table below shows the average number of nodes explored in function of the size of the problem and of the variable and node selection strategies. The corresponding plot is given afterwards.

```{r, echo=FALSE}

gen_table_nodes(tab)
gen_plot_nodes(tab)
```





# Study on the coefficients of the objective function

In this section, relations between |YN| and various characteristics of the coefficient of the objective function are studied.

## Knapsack

The relation between |YN| (x-axis), the proportion of non-dominated objective function coefficients (y-axis) and the number of variables (color-axis) is shown in the next plot.

```{r,echo=FALSE}
pbb = "KP"
gen_plot_correl_coef(dat,pbb)
```

The next plots study the impact of the range of the range of the objective function coefficient on |YN|. This is done separately for each coefficient generation methods.

```{r,echo=FALSE}
meth <- c("random","spheredown","sphereup","2box")
for (m in meth) {
  gen_plot_range(dat,pbb,m)  
}
```

The next plots study the impact of the method used for the generation of the objective function coefficient on |YN|. This is done separately for each possible ranges for the coefficients.

```{r,echo=FALSE}
ranmin <- c(1,1,1000)
ranmax <- c(10,1000,2000)
for (i in 1:3) {
  gen_plot_coef(dat,pbb,ranmin[i],ranmax[i])  
}
```


## Assignment

The relation between |YN| (x-axis), the proportion of non-dominated objective function coefficients (y-axis) and the number of variables (color-axis) is shown in the next plot.

```{r,echo=FALSE}
pbb = "AS"
gen_plot_correl_coef(dat,pbb)
```

The next plots study the impact of the range of the range of the objective function coefficient on |YN|. This is done separately for each coefficient generation methods.

```{r,echo=FALSE}
meth <- c("random","spheredown","sphereup","2box")
for (m in meth) {
  gen_plot_range(dat,pbb,m)  
}
```

The next plots study the impact of the method used for the generation of the objective function coefficient on |YN|. This is done separately for each possible ranges for the coefficients.

```{r,echo=FALSE}
ranmin <- c(1,1,1000)
ranmax <- c(10,1000,2000)
for (i in 1:3) {
  gen_plot_coef(dat,pbb,ranmin[i],ranmax[i])  
}
```


## Facility location easy

The relation between |YN| (x-axis), the proportion of non-dominated objective function coefficients (y-axis) and the number of variables (color-axis) is shown in the next plot.

```{r,echo=FALSE}
pbb = "FLe"
gen_plot_correl_coef(dat,pbb)
```

The next plots study the impact of the range of the range of the objective function coefficient on |YN|. This is done separately for each coefficient generation methods.

```{r,echo=FALSE}
meth <- c("random","spheredown","sphereup","2box")
for (m in meth) {
  gen_plot_range(dat,pbb,m)  
}
```

The next plots study the impact of the method used for the generation of the objective function coefficient on |YN|. This is done separately for each possible ranges for the coefficients.

```{r,echo=FALSE}
ranmin <- c(1,1,1000)
ranmax <- c(10,1000,2000)
for (i in 1:3) {
  gen_plot_coef(dat,pbb,ranmin[i],ranmax[i])  
}
```



## Facility location hard

The relation between |YN| (x-axis), the proportion of non-dominated objective function coefficients (y-axis) and the number of variables (color-axis) is shown in the next plot.

```{r,echo=FALSE}
pbb = "FLh"
gen_plot_correl_coef(dat,pbb)
```

The next plots study the impact of the range of the range of the objective function coefficient on |YN|. This is done separately for each coefficient generation methods.

```{r,echo=FALSE}
meth <- c("random","spheredown","sphereup","2box")
for (m in meth) {
  gen_plot_range(dat,pbb,m)  
}
```

The next plots study the impact of the method used for the generation of the objective function coefficient on |YN|. This is done separately for each possible ranges for the coefficients.

```{r,echo=FALSE}
ranmin <- c(1,1,1000)
ranmax <- c(10,1000,2000)
for (i in 1:3) {
  gen_plot_coef(dat,pbb,ranmin[i],ranmax[i])  
}
```

end
