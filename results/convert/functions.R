## Functions related to the convex hull

#' Return the dimension of the convex hull of a set of points.
#'
#' @param pts A matrix/data frame/vector that can be converted to a matrix with a row for each
#'   point.
#' @param dim The dimension of the points, i.e. assume that column 1-dim specify the points. If
#'   NULL assume that the dimension are the number of columns.
#'
#' @return The dimension of the object.
#' @export
#'
#' @examples
#' ## In 1D
#' pts <- matrix(c(3), ncol = 1, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix(c(1,3,4), ncol = 1, byrow = TRUE)
#' dimFace(pts)
#'
#' ## In 2D
#' pts <- matrix(c(3,3,6,3,3,6), ncol = 2, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix(c(1,1,2,2,3,3), ncol = 2, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix(c(0,0), ncol = 2, byrow = TRUE)
#' dimFace(pts)
#'
#' ## In 3D
#' pts <- c(3,3,3,6,3,3,3,6,3,6,6,3)
#' dimFace(pts, dim = 3)
#' pts <- matrix( c(1,1,1), ncol = 3, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix( c(1,1,1,2,2,2), ncol = 3, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix(c(2,2,2,3,2,2), ncol=3, byrow= TRUE)
#' dimFace(pts)
#' pts <- matrix(c(0,0,0,0,1,1,0,2,2,0,5,2,0,6,1), ncol = 3, byrow = TRUE)
#' dimFace(pts)
#' pts <- matrix(c(0,0,0,0,1,1,0,2,2,0,0,2,1,1,1), ncol = 3, byrow = TRUE)
#' dimFace(pts)
#'
#' ## In 4D
#' pts <- matrix(c(2,2,2,3,2,2,3,4,1,2,3,4), ncol=4, byrow= TRUE)
#' dimFace(pts,)
dimFace<-function(pts, dim = NULL) {
   if (is.null(dim)) dim <- ncol(pts)
   if (is.vector(pts)) pts <- matrix(pts, ncol = dim, byrow = TRUE)
   x <- as.matrix(unique(pts[,1:dim,drop=FALSE]))
   if (nrow(x)==1) return(0)
   m1 <- x[2:dim(x)[1],]
   m2 <- matrix(rep(x[1,], times = dim(x)[1]-1), ncol = dim(x)[2], byrow = TRUE)
   x <- m1 - m2
   return(Matrix::rankMatrix(x)[1])
}


#' Efficient test for points inside a convex hull in p dimensions.
#'
#' @param pts A \eqn{nxp} array to test, \eqn{n} data points, in dimension \eqn{p}. If you have
#'   many points to test, it is most efficient to call this function once with the entire set.
#' @param vertices A \eqn{mxp} array of vertices of the convex hull.
#' @param hull Tessellation (or triangulation) generated by convhulln (only works if the dimension
#'   of the hull is \eqn{p}). If hull is \code{NULL}, then it will be generated.
#' @param tol Tolerance on the tests for inclusion in the convex hull. You can think of tol as the
#'   distance a point may possibly lie outside the hull, and still be perceived as on the surface
#'   of the hull. Because of numerical slop nothing can ever be done exactly here. In higher
#'   dimensions, the numerical issues of floating point arithmetic will probably suggest a larger
#'   value of tol.
#'
#' @note Some of the code are inspired by the Matlab code by John D'Errico
#'   http://www.mathworks.com/matlabcentral/fileexchange/10226-inhull and
#'   https://tolstoy.newcastle.edu.au/R/e8/help/09/12/8784.html. If the dimension of the hull is
#'   below \eqn{p} then PCA may be used to check (a warning will be given).
#'
#' @return An integer vector of length \eqn{n} with values 1 (inside hull), -1 (outside hull) or 0
#'   (on hull to precision indicated by tol).
#'
#' @author Lars Relund \email{lars@@relund.dk}
#' @export
#'
#' @examples
#' ## In 1D
#' vertices <- matrix(4, ncol = 1)
#' pt <- matrix(c(2,4), ncol = 1, byrow = TRUE)
#' inHull(pt, vertices)
#' vertices <- matrix(c(1,4), ncol = 1)
#' pt <- matrix(c(1,3,4,5), ncol = 1, byrow = TRUE)
#' inHull(pt, vertices)
#'
#' ## In 2D
#' vertices <- matrix(c(2,4), ncol = 2)
#' pt <- matrix(c(2,4, 1,1), ncol = 2, byrow = TRUE)
#' inHull(pt, vertices)
#' vertices <- matrix(c(0,0, 3,3), ncol = 2, byrow = TRUE)
#' pt <- matrix(c(0,0, 1,1, 2,2, 3,3, 4,4), ncol = 2, byrow = TRUE)
#' inHull(pt, vertices)
#' vertices <- matrix(c(0,0, 0,3, 3,0), ncol = 2, byrow = TRUE)
#' pt <- matrix(c(0,0, 1,1, 4,4), ncol = 2, byrow = TRUE)
#' inHull(pt, vertices)
#'
#' ## in 3D
#' vertices <- matrix(c(2,2,2), ncol = 3, byrow = TRUE)
#' pt <- matrix(c(1,1,1, 3,3,3, 2,2,2, 3,3,2), ncol = 3, byrow = TRUE)
#' inHull(pt, vertices)
#'
#' vertices <- matrix(c(2,2,2, 4,4,4), ncol = 3, byrow = TRUE)
#' ini3D()
#' plotHull3D(vertices)
#' pt <- matrix(c(1,1,1, 2,2,2, 3,3,3, 4,4,4, 3,3,2), ncol = 3, byrow = TRUE)
#' plotPoints3D(pt, addText = TRUE)
#' finalize3D()
#' inHull(pt, vertices)
#'
#' vertices <- matrix(c(1,0,0, 1,1,0, 1,0,1), ncol = 3, byrow = TRUE)
#' ini3D()
#' plotHull3D(vertices)
#' pt <- matrix(c(1,0.1,0.2, 3,3,2), ncol = 3, byrow = TRUE)
#' plotPoints3D(pt, addText = TRUE)
#' finalize3D()
#' inHull(pt, vertices)
#'
#' vertices <- matrix(c(2,2,2, 2,4,4, 2,2,4, 4,4,2, 4,2,2, 2,4,2, 4,2,4, 4,4,4), ncol = 3,
#'             byrow = TRUE)
#' ini3D()
#' plotHull3D(vertices)
#' pt <- matrix(c(1,1,1, 3,3,3, 2,2,2, 3,3,2), ncol = 3, byrow = TRUE)
#' plotPoints3D(pt, addText = TRUE)
#' finalize3D()
#' inHull(pt, vertices)
#'
#' ## In 5D
#' vertices <- matrix(c(4,0,0,0,0, 0,4,0,0,0, 0,0,4,0,0, 0,0,0,4,0, 0,0,0,0,4, 0,0,0,0,0),
#'             ncol = 5, byrow = TRUE)
#' pt <- matrix(c(0.1,0.1,0.1,0.1,0.1, 3,3,3,3,3, 2,0,0,0,0), ncol = 5, byrow = TRUE)
#' inHull(pt, vertices)
inHull <- function(pts, vertices, hull=NULL,
                   tol=mean(mean(abs(as.matrix(vertices))))*sqrt(.Machine$double.eps)) {
   # ensure arguments are matrices (not data frames) and get sizes
   pts <- .checkPts(pts)
   vertices <- .checkPts(vertices)

   p <- ncol(vertices)   # dimension of points
   cx <- nrow(pts)   # points to test
   d <- dimFace(vertices, dim = p)
   if (d == 0) return(-as.integer(apply(pts, 1, FUN = function(x) any(x != vertices[1,]))))
   if (p == 1) {
      m <- min(vertices)
      M <- max(vertices)
      val <- rep(0,cx)
      val[pts > M | pts < m] <- -1
      val[pts < M & pts > m] <- 1
      return(val)
   }
   if (d == 1) { # a line, i.e. assume vertices contain two points
      l <- apply(pts, 1, FUN = function(x) {(x-vertices[1,])/(vertices[2,]-vertices[1,])})
      eq <- apply(l, 2, FUN = function(x) abs(max(x) - min(x)) < tol)
      l <- apply(l, 2, FUN = function(x) max(x) < 1 + tol & min(x) > -tol)
      l <- eq & l
      return(-as.integer(!l))
   }
   if (p == 2 & d != 2) {
      val <- grDevices::chull(rbind(vertices,pts))
      nrp <- nrow(vertices)
      outside <- unique(val[val>nrp])-nrp
      done <- FALSE
      while(!done){
         val <- grDevices::chull(rbind(vertices,pts[-(outside),]))
         also.outside <- (1:cx)[-outside][unique(val[val>nrp])-nrp]
         outside <- c(outside,also.outside)
         done <- length(also.outside)==0
      }
      val <- rep(0,cx)
      val[outside] <- -1
      return(val)
   }
   if (p == d) {
      if (is.null(hull)) hull <- geometry::convhulln(vertices)
      nt <- nrow(hull)    # number of simplexes in hull
      # find normal vectors to each simplex
      nrmls <- matrix(NA, nt, p)         # predefine each nrml as NA, degenerate
      degenflag <- matrix(TRUE, nt, 1)
      for (i in  1:nt) {
         nullsp <-
            t(MASS::Null(t(
               vertices[hull[i,-1],] - matrix(vertices[hull[i, 1],], p - 1, p, byrow =
                                                 TRUE)
            )))
         if (dim(nullsp)[1] == 1) {
            nrmls[i, ] <- nullsp
            degenflag[i] <- FALSE
         }
      }
      # Warn of degenerate faces, and remove corresponding normals
      if (sum(degenflag) > 0)
         warning(sum(degenflag), " degenerate faces in convex hull")
      nrmls <- nrmls[!degenflag, ]
      nt <- nrow(nrmls)
      # find center point in hull, and any (1st) point in the plane of each simplex
      center = colMeans(vertices)
      a <- vertices[hull[!degenflag, 1], ]
      # scale normal vectors to unit length and ensure pointing inwards
      nrmls <- nrmls / matrix(apply(nrmls, 1, function(x) sqrt(sum(x ^ 2))), nt, p)
      dp <- sign(apply((matrix(center, nt, p, byrow = TRUE) - a) * nrmls, 1, sum))
      nrmls <- nrmls * matrix(dp, nt, p)
      # if  min across all faces of dot((x - a),nrml) is
      #      +ve then x is inside hull
      #      0   then x is on hull
      #      -ve then x is outside hull
      # Instead of dot((x - a),nrml)  use dot(x,nrml) - dot(a, nrml)
      aN <- diag(a %*% t(nrmls))
      val <- apply(pts %*% t(nrmls) - matrix(aN, cx, nt, byrow = TRUE), 1, min)
      # code  values inside 'tol' to zero, return sign as integer
      val[abs(val) < tol] <- 0
      return(as.integer(sign(val)))
   }
   if (p != d) {  # note p>2
      outside <- rep(2,cx)
      row.names(pts) <- 1:nrow(pts)
      nrp <- nrow(vertices)
      done <- FALSE
      while(!done){
         pt <- pts[which(outside != -1),,drop=F]
         set <- rbind(vertices,pt)
         dS <- dimFace(set, dim = p)
         if (p == dS) {
            val <- geometry::convhulln(set)
            idx <- as.integer(row.names(pt[unique(val[val>nrp])-nrp,,drop=F]))
            outside[idx] <- -1
            done <- all(outside != 2)
         }
         if (dS != p) {
            idx <- as.integer(row.names(pt))
            warning(
               "Using PCA to transform. Results for index ",
               paste(idx, collapse = ","),
               " might not be accurate!"
            )
            set <- stats::princomp(set)
            idx <- which(set$sdev > tol)
            set <- stats::predict(set)[,idx]
            # set <- prcomp(set, scale. = T, retx = T, rank = dS)$x
            val <- inHull(set[(nrp+1):nrow(set),], set[1:nrp,], tol = 5*tol)
            val[val == 1] <- 0
            outside[as.integer(row.names(pt))] <- val
            return(outside)
         }
      }
      return(outside)
   }
}


#' Find segments (lines) of a face.
#'
#' @param vertices A mxp array of vertices of the convex hull, as used by
#'   convhulln.
#' @param hull Tessellation (or triangulation) generated by convhulln If hull is
#'   left empty or not supplied, then it will be generated.
#' @param tol Tolerance on the tests for inclusion in the convex hull. You can
#'   think of tol as the distance a point may possibly lie outside the hull, and
#'   still be perceived as on the surface of the hull. Because of numerical slop
#'   nothing can ever be done exactly here. I might guess a semi-intelligent
#'   value of tol to be
#'
#'   tol = 1.e-13*mean(abs(vertices(:)))
#'
#'   In higher dimensions, the numerical issues of floating point arithmetic
#'   will probably suggest a larger value of tol.
#'
#' @return A matrix with segments.
#' @author Lars Relund \email{lars@@relund.dk}
hullSegment <- function(vertices, hull=geometry::convhulln(vertices),
                        tol=mean(mean(abs(vertices)))*sqrt(.Machine$double.eps)) {
   vertices <- as.matrix(vertices)
   p <- ncol(vertices)   # columns in vertices
   nt <- nrow(hull)    # number of simplexes in hull
   # find normal vectors to each simplex
   nrmls <- matrix(NA, nt, p)         # predefine each nrml as NA, degenerate
   degenflag <- matrix(TRUE, nt, 1)
   for (i in  1:nt) {
      nullsp <-
         t(MASS::Null(t(
            vertices[hull[i,-1],] - matrix(vertices[hull[i, 1],], p - 1, p, byrow =
                                              TRUE)
         )))
      if (dim(nullsp)[1] == 1) {
         nrmls[i, ] <- nullsp
         degenflag[i] <- FALSE
      }
   }
   nt <- nrow(nrmls)
   # find center point in hull, and any (1st) point in the plane of each simplex
   center = colMeans(vertices)
   a <- vertices[hull[, 1], ]
   # scale normal vectors to unit length and ensure pointing inwards
   nrmls <- nrmls / matrix(apply(nrmls, 1, function(x) sqrt(sum(x ^ 2))), nt, p)
   dp <- sign(apply((matrix(center, nt, p, byrow = TRUE) - a) * nrmls, 1, sum))
   nrmls <- nrmls * matrix(dp, nt, p)
   idx <- !duplicated(round(nrmls,10))
   nrmls <- nrmls[idx,]
   a <- a[idx,]
   aN <- diag(a %*% t(nrmls))
   res <- NULL
   m <- nrow(vertices)
   for( i in 1:m )
      for( j in 1:m )
         if( i < j ) {
            # Middle of the segment
            p <- .5 * vertices[i,] + .5 * vertices[j,]
            # Check if it is at the intersection of two planes
            tmp <- p %*% t(nrmls) - aN #matrix(aN, 1, nrow(nrmls), byrow = TRUE)
            if(sum( abs( tmp ) < 1e-6 ) >= 2) res <- rbind(res, c(i,j))
         }
   return(as.matrix(res))
}


#' Add all points on the bounding box hit by the rays.
#'
#' @param pts A data frame with all points
#' @param m Minimum values of the bounding box.
#' @param M Maximum vlaues of the bounding box.
#' @param direction Ray direction. If i'th entry is positive, consider the i'th column of the `pts`
#'   plus a value greater than on equal zero. If negative, consider the i'th column of the `pts`
#'   minus a value greater than on equal zero.
#'
#' @note Assume that `pts` has been checked using [.checkPts].
#' @return The points merged with the points on the bounding box. The column `pt` equals 1 if
#'   points from pts and zero otherwise.
#' @export
#'
#' @examples
#' pts <- genNDSet(3,10)[,1:3]
#' addRays(pts)
#' addRays(pts, dir = c(1,-1,1))
#' addRays(pts, dir = c(-1,-1,1), m = c(0,0,0), M = c(100,100,100))
#' pts <- genSample(5,20)[,1:5]
#' addRays(pts)
addRays <- function(pts, m = apply(pts,2,min)-5, M = apply(pts,2,max)+5, direction = 1) {
   pts <- as.data.frame(pts)
   p <- ncol(pts)
   if (length(direction) != p) direction = rep(direction[1],p)
   v <- purrr::map_dbl(1:p, function(i) if (sign(direction[i]) > 0) M[i] else m[i])
   names(v) <- colnames(pts)
   set <- cbind(pts, pt = 1) # point in (1=original set, 0=artificial)

   for (i in 1:nrow(pts)) {
      x <- dplyr::bind_rows(pts[i,,drop=FALSE],v)
      x <- as.list(x)
      x <- expand.grid(x)
      x$pt <- 0
      set <- rbind(set,x)
   }
   # colnames(set)[1:p] <- paste0("z",1:p)
   # dplyr::distinct(set, V1, .keep_all = TRUE)
   # rownames(set) <- 1:dim(set)[1]
   set <- set[rownames(unique(set[,1:p,drop=FALSE])),, drop=FALSE]
   # rownames(set)[set$pt==0][6] <- (nrow(pts)+1):nrow(set)  # may give error if number in first rows
   return(set)
}


#' Find the convex hull of a set of points.
#'
#' @param pts A matrix with a point in each row.
#' @param addRays Add the ray defined by `direction`.
#' @param useRGLBBox Use the RGL bounding box when add rays.
#' @param direction Ray direction. If i'th entry is positive, consider the i'th column of `pts`
#'   plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
#'   i'th column of `pts` minus a value greater than on equal zero (maximize objective $i$).
#' @param tol Tolerance on std. dev. if using PCA.
#'
#' @return A list with \code{hull} equal a matrix with row indices of the vertices defining each
#'   facet in the hull and \code{pts} equal the input points (and dummy points) and columns:
#'   \code{pt}, true if a point in the original input; false if a dummy point (a point on a ray).
#'   \code{vtx}, TRUE if a vertex in the hull.
#' @export
#'
#' @examples
#' ## 1D
#' pts<-matrix(c(1,2,3), ncol = 1, byrow = TRUE)
#' dimFace(pts) # a line
#' convexHull(pts)
#' convexHull(pts, addRays = TRUE)
#'
#' ## 2D
#' pts<-matrix(c(1,1, 2,2), ncol = 2, byrow = TRUE)
#' dimFace(pts) # a line
#' convexHull(pts)
#' plotHull2D(pts, drawPoints = TRUE)
#' convexHull(pts, addRays = TRUE)
#' plotHull2D(pts, addRays = TRUE, drawPoints = TRUE)
#' pts<-matrix(c(1,1, 2,2, 0,1), ncol = 2, byrow = TRUE)
#' dimFace(pts) # a polygon
#' convexHull(pts)
#' plotHull2D(pts, drawPoints = TRUE)
#' convexHull(pts, addRays = TRUE, direction = c(-1,1))
#' plotHull2D(pts, addRays = TRUE, direction = c(-1,1), addText = "coord")
#'
#' ## 3D
#' pts<-matrix(c(1,1,1), ncol = 3, byrow = TRUE)
#' dimFace(pts) # a point
#' convexHull(pts)
#' pts<-matrix(c(0,0,0,1,1,1,2,2,2,3,3,3), ncol = 3, byrow = TRUE)
#' dimFace(pts) # a line
#' convexHull(pts)
#' pts<-matrix(c(0,0,0,0,1,1,0,2,2,0,0,2), ncol = 3, byrow = TRUE)
#' dimFace(pts) # a polygon
#' convexHull(pts)
#' convexHull(pts, addRays = TRUE)
#' pts<-matrix(c(1,0,0,1,1,1,1,2,2,3,1,1), ncol = 3, byrow = TRUE)
#' dimFace(pts) # a polygon
#' convexHull(pts) # a polyhedron
#' pts<-matrix(c(1,1,1,2,2,1,2,1,1,1,1,2), ncol = 3, byrow = TRUE)
#' dimFace(pts) # a polytope (polyhedron)
#' convexHull(pts)
#'
#' ini3D(argsPlot3d = list(xlim = c(0,3), ylim = c(0,3), zlim = c(0,3)))
#' pts<-matrix(c(1,1,1,2,2,1,2,1,1,1,1,2), ncol = 3, byrow = TRUE)
#' plotPoints3D(pts)
#' plotHull3D(pts, argsPolygon3d = list(color = "red"))
#' convexHull(pts)
#' plotHull3D(pts, addRays = TRUE)
#' convexHull(pts, addRays = TRUE)
#' finalize3D()
convexHull <- function(pts, addRays = FALSE, useRGLBBox = FALSE, direction = 1,
                       tol = mean(mean(abs(pts)))*sqrt(.Machine$double.eps)*2) {
   pts <- .checkPts(pts)
   p <- ncol(pts)
   if (length(direction) != p) direction = rep(direction[1],p)
   # print(set)
   if (addRays) {
      if (rgl::rgl.cur() > 0 & useRGLBBox) {
         limits <- rgl::par3d()$bbox
         for (i in 1:dim(pts)[1]) {
            pt <- as.vector(pts[i,])
            if (!(limits[1] < pt[1] && pt[1] < limits[2] &&
                  limits[3] < pt[2] && pt[2] < limits[4] &&
                  limits[5] < pt[3] && pt[3] < limits[6])){
               stop("The point is not in the interior of the current bounding box. Resize your axes.")
            }
         }
         m <- c(limits[1], limits[3], limits[5])
         M <- c(limits[2], limits[4], limits[6])
         set <- addRays(pts, m, M, direction)
      } else set <- addRays(pts, direction = direction)
   } else {
      set <- cbind(pts, pt = 1) # point in (1=original set, 0=artificial)
   }
   d <- dimFace(set[,1:p, drop = FALSE])
   # cat("Object of dimension",d,"\n")

   ## note p can be > 3 !!
   hull <- NULL
   if (d==0) { # a point
      hull <- 1
   } else if (d==p) { # same dimension as space
      if (p == 1) hull <- grDevices::chull(cbind(set[,1:p],0))
      if (p == 2) hull <- grDevices::chull(set[,1:p])
      if (p > 2) hull <- geometry::convhulln(set[,1:p], return.non.triangulated.facets = TRUE)
   } else if (d==1) { # a line (d<p)
      l <- nrow(set)
      n <- p
      comb <- t(utils::combn(n,2))
      for (i in 1:dim(comb)[1]) {  # simple projection down on each axis
         pt <- unique(set[,comb[i,]])
         if (l == dim(pt)[1]) {
            hull <- grDevices::chull(pt)
            if (length(hull)==2) {
               hull <- as.numeric(rownames(pt[hull,]))
               break
            }
         }
      }
   } else if (d==2) { # a plane (d<p)
      l <- nrow(set)
      tmp <- cbind(set, id = 1:l)
      comb <- t(utils::combn(p,2))
      for (i in 1:dim(comb)[1]) {  # simple projection down on each axis (keep the projection with highest number of vertices)
         pt <- unique(set[,comb[i,]])
         iL <- 0
         if (l == dim(pt)[1]) {
            hull <- grDevices::chull(pt)
            if (length(hull)>iL) {
               iL <- length(hull)
               hB <- rownames(pt[hull,])
            }
         }
      }
      hull <- tmp[hB,'id'] # return idx of set
   } else { # d > 2 & d < p
      warning(
         "Using PCA to transform. Results might not be accurate!"
      )
      set1 <- stats::prcomp(set[,1:p])
      # set1 <- stats::princomp(set[,1:p])
      idx <- which(set1$sdev > tol)
      set1 <- stats::predict(set1)[,idx, drop = FALSE]
      if (ncol(set1) == 1) hull <- grDevices::chull(cbind(set1,0))
      if (ncol(set1) == 2) hull <- grDevices::chull(set1)
      if (ncol(set1) > 2) hull <- geometry::convhulln(set1, return.non.triangulated.facets = TRUE)
   }
   if (is.vector(hull)) hull <- matrix(hull, nrow = 1)
   ## classify
   idx <- unique(as.vector(hull))
   idx <- idx[!is.na(idx)]
   idx <- sort(idx)
   set <- as.data.frame(set)
   set$vtx <- FALSE
   set$vtx[idx] <- TRUE
   # remove unwarnted dummy points
   set$oldId <- 1:nrow(set)
   tmp <- dplyr::filter(set, .data$vtx | .data$pt, .preserve = TRUE)
   if (nrow(set) != nrow(tmp)) {
      tmp$newId <- 1:nrow(tmp)
      mch <- dplyr::left_join(set, tmp, by = 'oldId') %>% dplyr::select(.data$newId)
      hull <- apply(hull, c(1,2), function(id) {if (is.na(id)) return(NA) else return(mch[id,1])} )
      set <- dplyr::select(tmp, -.data$oldId, -.data$newId)
   } else set <- dplyr::select(tmp, -.data$oldId)
   return(list(hull = hull, pts = set))
   stop("Cannot find the vertices!")
}



#' Check if point input is okay
#'
#' @param pts Point input.
#' @param p Desired dimension of points.
#' @param warn Output warnings.
#' @param stopUnique Stop if rows not are unique.
#' @param asDF Return as data frame otherwise as matrix.
#'
#' @return Point input converted to a matrix.
#' @keywords internal
.checkPts <- function(pts, p = NULL, warn = FALSE, stopUnique = TRUE, asDF = FALSE) {
   if (is.vector(pts)) {
      if (warn) warning("Point specified as a vector. Converting to a matrix with a single row!")
      pts <- t(matrix(pts))
   }
   if (stopUnique) {
      set <- as.matrix(unique(pts[,, drop = FALSE]))
      if (nrow(pts) != nrow(set)) {
         stop("Points specified should be unique!")
      }
   }
   if (!is.null(p))
      if (ncol(pts) != p) {
         stop("The dimension of the points should be ", p, "!")
      }
   if (!asDF) {
      if (is.data.frame(pts)) {
         if (warn) warning("Points specified as a data frame. Converting to a matrix!")
         pts <- as.matrix(pts)
      }
   } else pts <- as.data.frame(pts)
   if (is.null(rownames(pts))) rownames(pts) <- 1:nrow(pts)
   if (is.null(colnames(pts))) colnames(pts) <- paste0("p",1:ncol(pts))
   return(pts)
}

#' Convert min/max to direction (1/-1)
#'
#' @param m Min/max vector.
#' @param p Number of objectives.
#'
#' @return A direction vector (min = 1 and max = -1)
#' @keywords internal
.mToDirection <- function(m, p) {
   if (length(m) != p) m <- rep(m[1],p)
   return(dplyr::if_else(m == "min", 1, -1))
}

#' Add discrete points to a non-dominated set and classify them into extreme supported, non-extreme
#' supported, non-supported.
#'
#' @param pts A data frame with points to add (a column for each objective).
#' @param nDSet A data frame with current non-dominated set (NULL is none yet). Column names of the
#'   p objectives must be z1, ..., zp.
#' @param crit A max or min vector. If length one assume all objectives are optimized in the same
#'   direction.
#' @param keepDom Keep dominated points in output.
#' @param dubND Dublicated non-dominated points are classified as non-dominated.
#' @param classify Non-dominated points are classified into supported extreme (se), supported
#'   non-extreme (sne) and unsupported (us)
#'
#' @return A data frame with a column for each objective (`z` columns) and nd (non-dominated).
#'   Moreover if `classify` then columns `se`, `sne`, `us` and `cls`.
#'
#' @author Lars Relund \email{lars@@relund.dk}
#' @export
#'
#' @examples
#' nDSet <- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4))
#' pts <- data.frame(z1 = c(18,18,14,15,15), z2=c(2,6,14,14,16))
#' addNDSet(pts, nDSet, crit = "max")
#' addNDSet(pts, nDSet, crit = "max", keepDom = TRUE)
#' addNDSet(pts, nDSet, crit = "min")
#' addNDSet(c(2,2), nDSet, crit = "max")
#' addNDSet(c(2,2), nDSet, crit = "min")
#'
#' addNDSet(c(2,2), crit = "min")
#'
#' nDSet <- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4), z3 = c(1,7,0,6))
#' pts <- data.frame(z1=c(12,14,16,18), z2=c(18,16,12,4), z3 = c(2,2,2,6))
#' crit = c("min", "min", "max")
#' di <- c(1,1,-1)
#' li <- c(-1,20)
#' ini3D(argsPlot3d = list(xlim = li, ylim = li, zlim = li))
#' plotCones3D(nDSet, direction = di, argsPolygon3d = list(color = "green", alpha = 1),
#'             drawPoint = FALSE)
#' plotHull3D(nDSet, addRays = TRUE, direction = di)
#' plotPoints3D(nDSet, argsPlot3d = list(col = "red"), addText = "coord")
#' plotPoints3D(pts, addText = "coord")
#' finalize3D()
#' addNDSet(pts, nDSet, crit, dubND = FALSE)
#' addNDSet(pts, nDSet, crit, dubND = TRUE)
#' addNDSet(pts, nDSet, crit, dubND = TRUE, keepDom = TRUE)
#' addNDSet(pts, nDSet, crit, dubND = TRUE, keepDom = TRUE, classify = FALSE)
addNDSet<-function(pts, nDSet = NULL, crit = "max", keepDom = FALSE, dubND = FALSE,
                   classify = TRUE)
{
   if (is.data.frame(nDSet))
      nDSet$nd <- NULL; nDSet$se <- NULL; nDSet$sne <- NULL; nDSet$us <- NULL
      if (!is.data.frame(pts)) pts <- as.data.frame(.checkPts(pts, stopUnique = FALSE))
      p <- ncol(pts)
      direction <- .mToDirection(crit, p)
      colnames(pts) <- paste0("z",1:p)
      if (!is.null(nDSet)) {
         if (ncol(pts)!= ncol(nDSet))
            stop("Number of columns (not including classification colunms) must be the same!")
      } else {
         if (nrow(pts) == 1)
            return(mutate(pts, nd = TRUE, se = TRUE, sne = FALSE, us = FALSE, cls = "se"))
         nDSet <- pts[1,]
         pts <- pts[-1,]
      }
      set <- bind_rows(nDSet, pts)

      # new implem
      pf <- dplyr::if_else(direction == 1, "quo(", "quo(desc(")
      sf <- dplyr::if_else(direction == 1, ")", "))")
      args <- paste0("list(", paste0(pf, colnames(nDSet), sf, collapse = ", "), ")")
      args <- eval(parse(text=args))
      set <- set %>% dplyr::arrange(!!!args)  # sort based on direction, i.e. i<j => j cannot dom i
      set$nd <- TRUE
      if (dubND) {
         for (i in 1:(nrow(set)-1)) {
            for (j in (i+1):nrow(set)) {
               if (set$nd[j]) { # must check if i dom j and not eq
                  if (all(set[i, 1:p]*direction <= set[j, 1:p]*direction)) { # i may dom j
                     if (!(all(set[i, 1:p]*direction == set[j, 1:p]*direction))) set$nd[j] <- FALSE
                  }
               }
            }
         }
      } else {
         for (i in 1:(nrow(set)-1)) {
            for (j in (i+1):nrow(set)) {
               if (set$nd[j]) { # must check if i dom j
                  if (all(set[i, 1:p]*direction <= set[j, 1:p]*direction)) set$nd[j] <- FALSE
               }
            }
         }
      }

      # old implem
      # idx <- (nrow(nDSet)+1):nrow(set)
      # set$nd <- TRUE
      # if (dubND) {
      #    for (i in idx) {
      #       for (j in 1:(i-1)) {
      #          if (!set$nd[j]) next  # if j dom don't check against i
      #          less <- set[j,1:p]*direction < set[i,1:p]*direction
      #          eq <- set[j,1:p]*direction == set[i,1:p]*direction
      #          if (all(less | eq) & !all(eq)) {set$nd[i] <- FALSE; break} # j strict dom i
      #          if (all(!less | eq) & !all(eq)) set$nd[j] <- FALSE # i strict dom j
      #       }
      #    }
      # } else {
      #    for (i in idx) {
      #       for (j in 1:(i-1)) {
      #          if (!set$nd[j]) next  # if j dom don't check against i
      #          less <- set[j,1:p]*direction < set[i,1:p]*direction
      #          eq <- set[j,1:p]*direction == set[i,1:p]*direction
      #          if (all(less | eq)) {set$nd[i] <- FALSE;  break} # j dom i
      #          if (all(!less | eq) & !all(eq)) set$nd[j] <- FALSE # i strict dom j
      #       }
      #    }
      # }

      if (!keepDom) set <- set %>% dplyr::filter(.data$nd)
      if (classify) {
         set1 <- classifyNDSet(set[set$nd,1:p], direction)
         set <- set %>% tibble::rownames_to_column(var = "id")
         ids <- set$id[set$nd]
         set1 <- set1 %>% tibble::add_column(id = set$id[set$nd], .before = 1)
         set <- left_join(x = set, y = set1, by = c("id", colnames(pts)))
         if (keepDom) set <- set %>%
            mutate_if(is.factor, as.character) %>%
            tidyr::replace_na(list(se = FALSE, sne = FALSE, us = TRUE, cls = "d"))
         set <- set %>% select(-id)
      }
      return(set)

      # iP = pts
      # colnames(iP)[1:2] <- paste0("z", 1:2)
      # #iP <- round(iP,10)
      # rownames(iP) <- NULL
      # iP <- rbind(iP, nDSet)
      # tol <- 1e-4
      # iP$oldRowIdx <- 1:length(iP$z1)
      # if (crit=="max") iP <- iP[order(-iP$z2,-iP$z1),]
      # if (crit=="min") iP <- iP[order(iP$z2,iP$z1),]
      #
      # # classify non dom
      # iP$nD <- FALSE
      # iP$nD[1] <- TRUE  # upper left point
      # p1 <- iP$z1[1]; p2 <- iP$z2[1]  # current non dom point (due to sorting will p2 always be larger than or equal to current)
      # for (r in 2:length(iP$z1)) { # current point under consideration
      #    if (abs(p2 - iP$z2[r]) < tol &
      #        abs(p1 - iP$z1[r]) < tol) {
      #       iP$nD[r] <- TRUE
      #       p1 <- iP$z1[r]
      #       p2 <- iP$z2[r]
      #       next
      #    }
      #    if (crit == "max" &
      #        p2 - iP$z2[r] > tol &
      #        iP$z1[r] > p1 + tol) {
      #       iP$nD[r] <- TRUE
      #       p1 <- iP$z1[r]
      #       p2 <- iP$z2[r]
      #       next
      #    }
      #    if (crit == "min" &
      #        iP$z2[r] - p2 > tol &
      #        iP$z1[r] < p1 - tol) {
      #       iP$nD[r] <- TRUE
      #       p1 <- iP$z1[r]
      #       p2 <- iP$z2[r]
      #       next
      #    }
      # }
      # # iP$nD <- TRUE
      # # for (i in 2:nrow(iP)) { # remove non-dom z2
      # #    if (iP$z2[i-1]==iP$z2[i]) iP$nD[i] <- FALSE
      # # }
      # # if (!keepDom) iP <- iP[iP$nD,]
      # # for (i in 2:nrow(iP)) { # remove non-dom z1
      # #    if (iP$z1[i-1]==iP$z1[i]) iP$nD[i] <- FALSE
      # # }
      # if (!keepDom) iP <- iP[iP$nD,]
      # iP$rowIdx <- 1:nrow(iP)
      # # classify extreme supported
      # idx <- which(iP$nD & !duplicated(cbind(iP$z1,iP$z2), MARGIN = 1) )  # remove dublicated points
      # iP$ext <- FALSE
      # iP$ext[idx[1]] <- TRUE
      # iP$ext[idx[length(idx)]] <- TRUE
      # if (length(idx)<3) {
      #    iP$nonExt <- FALSE
      #    #return(iP)   # a single extreme
      # } else {
      #    nD <- iP[idx,]
      #    ul<-1
      #    lr<-length(idx)
      #    while (ul<length(idx)) {
      #       # for (k in 1:1000) {
      #       slope <- (nD$z2[lr]-nD$z2[ul])/(nD$z1[lr]-nD$z1[ul])
      #       nD$val <- nD$z2-slope*nD$z1
      #       #cat("val:",nD$val[ul],"max:",max(nD$val),"min:",min(nD$val),"\n")
      #       if (crit=="max") {
      #          i <- which.max(nD$val)
      #          if (nD$val[ul]<nD$val[i] - tol) {
      #             iP$ext[nD$rowIdx[i]] <- TRUE
      #             lr <- i
      #          } else {
      #             ul <- lr
      #             lr<-length(idx)
      #          }
      #       }
      #       if (crit=="min") {
      #          i <- which.min(nD$val)
      #          if (nD$val[ul]>nD$val[i] + tol) {
      #             iP$ext[nD$rowIdx[i]] <- TRUE
      #             lr <- i
      #          } else {
      #             ul <- lr
      #             lr<-length(idx)
      #          }
      #       }
      #    }
      #    # classify nonextreme supported
      #    idxExt <- which(iP$ext)
      #    iP$nonExt <- FALSE
      #    if (length(idxExt)>1) {
      #       for (i in 2:length(idxExt)) {
      #          slope <- (iP$z2[idxExt[i]]-iP$z2[idxExt[i-1]])/(iP$z1[idxExt[i]]-iP$z1[idxExt[i-1]])
      #          nDCand <- iP[idxExt[i-1]:idxExt[i],]
      #          nDCand <- nDCand[nDCand$nD & !duplicated(cbind(nDCand$z1,nDCand$z2), MARGIN = 1),]
      #          nDCand <- nDCand[c(-1,-length(nDCand$nD)),]
      #          if (length(nDCand$nD)==0) next   # no points inbetween
      #          for (j in 1:length(nDCand$nD)) {
      #             slopeCur = (nDCand$z2[j]-iP$z2[idxExt[i-1]])/(nDCand$z1[j]-iP$z1[idxExt[i-1]])
      #             if (abs(slope - slopeCur) < tol) iP$nonExt[nDCand$rowIdx[j]==iP$rowIdx] <- TRUE
      #          }
      #       }
      #    }
      #    # classify dublicates
      #    idx <- which(iP$nD)
      #    if (!length(idx)<2) {
      #       for (i in 2:length(idx)) {
      #          if (iP$ext[i-1] & abs(iP$z2[i-1]-iP$z2[i])<tol & abs(iP$z1[i-1]-iP$z1[i])<tol) {
      #             iP$ext[i] = TRUE
      #             next
      #          }
      #          if (iP$nonExt[i-1] & abs(iP$z2[i-1]-iP$z2[i])<tol & abs(iP$z1[i-1]-iP$z1[i])<tol) {
      #             iP$nonExt[i] = TRUE
      #          }
      #       }
      #    }
      # }
      # iP$rowIdx <- NULL
      # iP$oldRowIdx <- NULL
      # return(iP)
}







#' Classify a set of nondominated points
#'
#' The classification is supported (true/false), extreme (true/false), supported non-extreme
#' (true/false)
#'
#' @param pts A set of non-dominated points. It is assumed that `ncol(pts)` equals the number of
#'   objectives ($p$).
#' @param direction Ray direction. If i'th entry is positive, consider the i'th column of the `pts`
#'   plus a value greater than on equal zero (minimize objective $i$). If negative, consider the
#'   i'th column of the `pts` minus a value greater than on equal zero (maximize objective $i$).
#'
#' @note It is assumed that `pts` are nondominated.
#'
#' @return The ND set with classification columns.
#' @export
#'
#' @examples
#' pts <- matrix(c(0,0,1, 0,1,0, 1,0,0, 0.5,0.2,0.5, 0.25,0.5,0.25), ncol = 3, byrow = TRUE)
#' ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-2,max(pts[,1])+2),
#'   ylim = c(min(pts[,2])-2,max(pts[,2])+2),
#'   zlim = c(min(pts[,3])-2,max(pts[,3])+2)))
#' plotHull3D(pts, addRays = TRUE, argsPolygon3d = list(alpha = 0.5), useRGLBBox = TRUE)
#' pts <- classifyNDSet(pts[,1:3])
#' plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
#' plotPoints3D(pts[!pts$sne,1:3], argsPlot3d = list(col = "black"))
#' plotPoints3D(pts[!pts$us,1:3], argsPlot3d = list(col = "blue"))
#' plotCones3D(pts[,1:3], rectangle = TRUE, argsPolygon3d = list(alpha = 1))
#' finalize3D()
#' pts
#'
#' pts <- matrix(c(0,0,1, 0,1,0, 1,0,0, 0.2,0.1,0.1, 0.1,0.45,0.45), ncol = 3, byrow = TRUE)
#' di <- -1 # maximize
#' ini3D(argsPlot3d = list(xlim = c(min(pts[,1])-1,max(pts[,1])+1),
#'   ylim = c(min(pts[,2])-1,max(pts[,2])+1),
#'   zlim = c(min(pts[,3])-1,max(pts[,3])+1)))
#' plotHull3D(pts, addRays = TRUE, argsPolygon3d = list(alpha = 0.5), direction = di,
#'            addText = "coord")
#' pts <- classifyNDSet(pts[,1:3], direction = di)
#' plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
#' plotPoints3D(pts[!pts$sne,1:3], argsPlot3d = list(col = "black"))
#' plotPoints3D(pts[!pts$us,1:3], argsPlot3d = list(col = "blue"))
#' plotCones3D(pts[,1:3], rectangle = TRUE, argsPolygon3d = list(alpha = 1), direction = di)
#' finalize3D()
#' pts
#'
#' pts <- matrix(c(0,0,1, 0,0,1, 0,1,0, 0.5,0.2,0.5, 1,0,0, 0.5,0.2,0.5, 0.25,0.5,0.25), ncol = 3,
#'               byrow = TRUE)
#' classifyNDSet(pts)
#'
#' pts <- genNDSet(3,50)[,1:3]
#' ini3D(argsPlot3d = list(xlim = c(0,max(pts$z1)+2),
#'   ylim = c(0,max(pts$z2)+2),
#'   zlim = c(0,max(pts$z3)+2)))
#' plotHull3D(pts, addRays = TRUE, argsPolygon3d = list(alpha = 0.5))
#' pts <- classifyNDSet(pts[,1:3])
#' plotPoints3D(pts[pts$se,1:3], argsPlot3d = list(col = "red"))
#' plotPoints3D(pts[!pts$sne,1:3], argsPlot3d = list(col = "black"))
#' plotPoints3D(pts[!pts$us,1:3], argsPlot3d = list(col = "blue"))
#' finalize3D()
#' pts
classifyNDSet <- function(pts, direction = 1) {
   pts <- .checkPts(pts, stopUnique = FALSE)
   p <- ncol(pts)
   colnames(pts) <- paste0("z", 1:p)
   idx <- duplicated(pts)
   pts <- pts %>% dplyr::as_tibble() %>% dplyr::mutate(id = 1:nrow(pts)) #%>%  tibble::rownames_to_column(var = "rn")
   if (nrow(pts) == 1) {
      pts <- as.data.frame(pts)
      return(cbind(select(pts,-id), se = TRUE, sne = FALSE, us = FALSE, cls = "se"))
   }
   if (length(direction) != p) direction = rep(direction[1],p)

   # find hull of the unique points and classify
   set <- convexHull(pts[!idx,1:p], addRays = TRUE, direction = direction)
   hull <- set$hull
   set <- set$pts
   d <- dimFace(set[,1:p])
   if (d != p) stop("The points including rays don't seem to define a hull of dimension ", p, "!")
   set <- dplyr::mutate(set, se = dplyr::if_else(.data$vtx,TRUE,FALSE))
   set <- dplyr::mutate(set, sne = FALSE, us = FALSE, id = 1:nrow(set))
   chk <- set %>% dplyr::filter(!.data$vtx)
   if (nrow(chk) != 0) {
      val <- inHull(chk[,1:p], set[set$vtx,1:p])
      set$us[chk$id[which(val == 1)]] <- TRUE
      set$sne[chk$id[which(val == 0)]] <- TRUE
   }
   set <- set %>% # tidy and add old id
      dplyr::filter(.data$pt == 1) %>%
      dplyr::mutate(cls = dplyr::if_else(.data$se, "se", dplyr::if_else(.data$sne, "sne", "us"))) %>%
      dplyr::select(tidyselect::all_of(1:p), c("se", "sne", "us", "cls")) %>%
      dplyr::mutate(id = which(!idx))
   set1 <- set %>% left_join(x = set, y = pts[idx,], by = paste0("z", 1:p)) # match id of dublicates
   set1 <- set1 %>%
      dplyr::filter(!is.na(.data$id.y)) %>%
      dplyr::mutate(id.x = .data$id.y) %>% dplyr::select(.data$z1:.data$id.x)
   set <- bind_rows(set, pts[idx,]) %>% arrange(id) %>% select(-id)
   if (nrow(set1) > 0) for (i in 1:nrow(set1)) set[set1$id.x[i],] <- set1[i, 1:(p+4)]
   return(set)
}
